// Generated by: setup
// TypeWriter: sorted_container
// Directive: +test on main.Thing

// SortedSet is a modification of https://github.com/wfreeman/go-skiplist/sortedset.go
// The MIT License (MIT)
// Copyright (c) 2014 Wes Freeman (freeman.wes@gmail.com)

package main

import (
	"math"
	"math/rand"
)

// The primary type that represents a sorted set
// backed by a skiplist
type ThingSortedSet struct {
	less      func(a, b Thing) bool
	head      []*sortedSetThingElement
	length    int
	maxLevels int
	r         *rand.Rand
}

// the struct to hold elements of the skiplist
type sortedSetThingElement struct {
	val  Thing
	next []*sortedSetThingElement
}

// Creates and returns a reference to an empty set.
func NewThingSortedSet(less func(Thing, Thing) bool) ThingSortedSet {
	return ThingSortedSet{
		less:      less,
		maxLevels: 64,
		head:      make([]*sortedSetThingElement, 64),
		r:         rand.New(rand.NewSource(123123)),
	}
}

func newSortedSetThingElement(v Thing, levels int) *sortedSetThingElement {
	return &sortedSetThingElement{v, make([]*sortedSetThingElement, levels)}
}

// Creates and returns a reference to a set from an existing slice
func NewThingSortedSetFromSlice(less func(Thing, Thing) bool, s []Thing) ThingSortedSet {
	a := NewThingSortedSet(less)
	for _, item := range s {
		a.Add(item)
	}
	return a
}

func (ss ThingSortedSet) randomLevels() int {
	level := int(math.Log(1.0-ss.r.Float64()) / math.Log(0.5))
	if level >= ss.maxLevels {
		level = ss.maxLevels
	}
	if level == 0 {
		level++
	}
	return level
}

// Adds an item to the current set if it doesn't already exist in the set.
func (ss ThingSortedSet) Add(v Thing) bool {
	var backPointer = make([]*sortedSetThingElement, 64)
	// zeroing this causes the compiler to not allocate memory each time
	// for a 20-30% boost in speed
	for i := 0; i < 64; i++ {
		backPointer[i] = nil
	}
	for level := ss.maxLevels - 1; level >= 0; level-- {
		var e *sortedSetThingElement = nil
		if level+1 == ss.maxLevels || backPointer[level+1] == nil {
			e = ss.head[level]
		} else {
			e = backPointer[level+1]
		}
		for e != nil {
			// if they are equal, overwrite?
			if ss.less(v, e.val) == ss.less(e.val, v) {
				return false
			}
			// if inspected val is greater than k, go back and down a level
			if ss.less(v, e.val) {
				break
			}
			backPointer[level] = e
			e = e.next[level]
		}
	}
	// create new element
	e := newSortedSetThingElement(v, ss.randomLevels())

	// connect new element up with backPointer
	for level := 0; level < len(e.next); level++ {
		if backPointer[level] == nil {
			e.next[level] = ss.head[level]
			ss.head[level] = e
		} else {
			e.next[level] = backPointer[level].next[level]
			backPointer[level].next[level] = e
		}
	}

	ss.length++
	return true
}

// Determines if a given item is already in the set.
func (ss ThingSortedSet) Contains(v Thing) bool {
	var backPointer = make([]*sortedSetThingElement, 64)
	// zeroing this causes the compiler to not allocate memory each time
	// for a 20-30% boost in speed
	for i := 0; i < 64; i++ {
		backPointer[i] = nil
	}
	for level := ss.maxLevels - 1; level >= 0; level-- {
		var e *sortedSetThingElement = nil
		if level+1 == ss.maxLevels || backPointer[level+1] == nil {
			e = ss.head[level]
		} else {
			e = backPointer[level+1]
		}
		for e != nil {
			// if they are equal, return val
			if ss.less(v, e.val) == ss.less(e.val, v) {
				return true
			}
			// if inspected val is greater than v, go back and down a level
			if ss.less(v, e.val) {
				break
			}
			backPointer[level] = e
			e = e.next[level]
		}
	}
	return false
}

// Determines if the given items are all in the set
func (ss ThingSortedSet) ContainsAll(i ...Thing) bool {
	for _, elem := range i {
		if !ss.Contains(elem) {
			return false
		}
	}
	return true
}

// Determines if every item in the other set is in this set.
func (ss ThingSortedSet) IsSubset(other ThingSortedSet) bool {
	e := ss.head[0]
	for e != nil {
		if !other.Contains(e.val) {
			return false
		}
		e = e.next[0]
	}
	return true
}

// Determines if every item of this set is in the other set.
func (ss ThingSortedSet) IsSuperset(other ThingSortedSet) bool {
	return other.IsSubset(ss)
}

// Returns a new set with all items in both sets.
func (ss ThingSortedSet) Union(other ThingSortedSet) ThingSortedSet {
	unionedSet := NewThingSortedSet(ss.less)

	e := ss.head[0]
	for e != nil {
		unionedSet.Add(e.val)
		e = e.next[0]
	}
	e = other.head[0]
	for e != nil {
		unionedSet.Add(e.val)
		e = e.next[0]
	}
	return unionedSet
}

// Returns a new set with items that exist only in both sets.
func (ss ThingSortedSet) Intersect(other ThingSortedSet) ThingSortedSet {
	intersection := NewThingSortedSet(ss.less)
	// loop over smaller set
	if ss.Cardinality() < other.Cardinality() {
		e := ss.head[0]
		for e != nil {
			if other.Contains(e.val) {
				intersection.Add(e.val)
			}
			e = e.next[0]
		}
	} else {
		e := other.head[0]
		for e != nil {
			if ss.Contains(e.val) {
				intersection.Add(e.val)
			}
			e = e.next[0]
		}
	}
	return intersection
}

// Returns a new set with items in the current set but not in the other set
func (ss ThingSortedSet) Difference(other ThingSortedSet) ThingSortedSet {
	differencedSet := NewThingSortedSet(ss.less)
	e := ss.head[0]
	for e != nil {
		if !other.Contains(e.val) {
			differencedSet.Add(e.val)
		}
		e = e.next[0]
	}
	return differencedSet
}

// Returns a new set with items in the current set or the other set but not in both.
func (ss ThingSortedSet) SymmetricDifference(other ThingSortedSet) ThingSortedSet {
	aDiff := ss.Difference(other)
	bDiff := other.Difference(ss)
	return aDiff.Union(bDiff)
}

// Clears the entire set to be the empty set.
func (ss *ThingSortedSet) Clear() {
	*ss = ThingSortedSet{
		less:      ss.less,
		maxLevels: 64,
		head:      make([]*sortedSetThingElement, 64),
		r:         rand.New(rand.NewSource(123123)),
	}
}

// Allows the removal of a single item in the set.
func (ss ThingSortedSet) Remove(v Thing) {
	var backPointer = make([]*sortedSetThingElement, 64)
	// zeroing this causes the compiler to not allocate memory each time
	// for a 20-30% boost in speed
	for i := 0; i < 64; i++ {
		backPointer[i] = nil
	}
	for level := ss.maxLevels - 1; level >= 0; level-- {
		var e *sortedSetThingElement = nil
		if level+1 == ss.maxLevels || backPointer[level+1] == nil {
			e = ss.head[level]
		} else {
			e = backPointer[level+1]
		}
		for e != nil {
			// if they are equal, remove
			if level == 0 && ss.less(v, e.val) == ss.less(e.val, v) {
				for level := 0; level < len(e.next); level++ {
					if backPointer[level] == nil {
						ss.head[level] = e.next[level]
					} else {
						backPointer[level].next[level] = e.next[level]
					}
				}

				ss.length--
			}
			if ss.less(v, e.val) == ss.less(e.val, v) {
				break
			}
			// if inspected val is greater than k, go back and down a level
			if ss.less(v, e.val) {
				break
			}
			backPointer[level] = e
			e = e.next[level]
		}
	}
}

// Cardinality returns how many items are currently in the set.
func (ss ThingSortedSet) Cardinality() int {
	e := ss.head[0]
	ret := 0
	for e != nil {
		ret++
		e = e.next[0]
	}
	return ret
}

// Iter() returns a channel of type Thing that you can range over.
func (ss ThingSortedSet) Iter() <-chan Thing {
	ch := make(chan Thing)
	go func() {
		e := ss.head[0]
		for e != nil {
			ch <- e.val
			e = e.next[0]
		}
		close(ch)
	}()

	return ch
}

// Equal determines if two sets are equal to each other.
// If they both are the same size and have the same items they are considered equal.
// Order of items is not relevent for sets to be equal.
func (ss ThingSortedSet) Equal(other ThingSortedSet) bool {
	if ss.Cardinality() != other.Cardinality() {
		return false
	}
	e := ss.head[0]
	for e != nil {
		if !other.Contains(e.val) {
			return false
		}
		e = e.next[0]
	}
	return true
}

// Returns a clone of the set.
// Does NOT clone the underlying elements.
func (ss ThingSortedSet) Clone() ThingSortedSet {
	clonedSet := NewThingSortedSet(ss.less)
	e := ss.head[0]
	for e != nil {
		clonedSet.Add(e.val)
		e = e.next[0]
	}
	return clonedSet
}
